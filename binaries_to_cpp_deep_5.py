import argparse
import asyncio
import os
import r2pipe
import time
from typing import Optional

class Decompiler:
    def __init__(self, output_dir: str = "decompiled_results"):
        self.output_dir = output_dir
        os.makedirs(self.output_dir, exist_ok=True)

    async def decompile(self, binary_path: str, main_function_only: bool = False,
                      max_functions: Optional[int] = None) -> Optional[str]:
        """Основной метод для декомпиляции бинарного файла"""
        if not os.path.isfile(binary_path):
            print(f"Error: File {binary_path} not found!")
            return None

        file_name = os.path.splitext(os.path.basename(binary_path))[0]
        output_path = os.path.join(self.output_dir, f"{file_name}_decompiled.cpp")

        try:
            start_time = time.time()  # Засекаем время начала
            await self._reverse_engineering_code(
                binary_path=binary_path,
                target_path=output_path,
                reverse_main_function=main_function_only,
                max_functions=max_functions
            )
            end_time = time.time()  # Засекаем время окончания

            # Подсчёт строк в итоговом файле
            with open(output_path, 'r') as f:
                line_count = sum(1 for _ in f)

            # Вывод финальной статистики
            print(f"\nDecompilation completed in {end_time - start_time:.2f} seconds")
            print(f"Total lines in output file: {line_count}")
            print(f"Successfully decompiled to {output_path}")

            return output_path
        except Exception as e:
            print(f"Decompilation failed: {str(e)}")
            return None

    async def _reverse_engineering_code(self, binary_path: str, target_path: str,
                                      reverse_main_function: bool, max_functions: Optional[int]) -> None:
        """Асинхронный запуск синхронной декомпиляции"""
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, self._reverse_engineering_code_sync,
                                   binary_path, target_path, reverse_main_function, max_functions)

    @staticmethod
    def _reverse_engineering_code_sync(binary_path: str, target_path: str,
                                     reverse_main_function: bool, max_functions: Optional[int]) -> None:
        """Синхронная декомпиляция с использованием radare2"""
        try:
            r2 = r2pipe.open(binary_path)
            r2.cmd("aaa")  # Анализ всего файла

            header = """/*
            This file was generated by local decompiler
            Generated code is for educational purposes only
            */\n\n
            """

            # Открываем файл для записи
            with open(target_path, "w") as output_file:
                # Записываем заголовок
                output_file.write(header)

                if reverse_main_function:
                    # Декомпиляция только main функции
                    r2.cmd("af main")
                    code = r2.cmd("pdd").strip()
                    cleaned = [line for line in code.split("\n") if line.strip()]
                    output_file.write("\n".join(cleaned[2:]) + "\n\n")
                    print("Decompilation completed: 100% (1/1 functions)")
                else:
                    # Декомпиляция всех или указанного количества функций
                    functions = r2.cmdj("aflj")
                    total_functions = len(functions)

                    # Ограничение количества функций если указано
                    if max_functions is not None:
                        functions = functions[:max_functions]
                        total_functions = max_functions

                    processed = 0

                    for func in functions:
                        addr = func['offset']
                        code = r2.cmd(f"pdd @{addr}").strip()
                        cleaned = [line for line in code.split("\n") if line.strip()]

                        # Записываем декомпилированную функцию в файл
                        output_file.write("\n".join(cleaned[2 if '#include' not in header else 3:]) + "\n\n")

                        processed += 1
                        progress = int((processed / total_functions) * 100)
                        print(f"Progress: {progress}% ({processed}/{total_functions} functions)", end="\r")

                    print()  # Для перехода на новую строку после прогресс-бара

        except Exception as e:
            raise RuntimeError(f"Radare2 error: {str(e)}")

def main():
    parser = argparse.ArgumentParser(description='Binary to C++ Decompiler')
    parser.add_argument('binary', help='Path to the executable file')
    parser.add_argument('-m', '--main-only', action='store_true',
                       help='Decompile only main function')
    parser.add_argument('-f', '--functions', type=int,
                       help='Number of functions to decompile (default: all)')
    parser.add_argument('-o', '--output-dir', default='decompiled_results',
                       help='Output directory for decompiled code')

    args = parser.parse_args()

    decompiler = Decompiler(args.output_dir)
    asyncio.run(decompiler.decompile(
        args.binary,
        args.main_only,
        max_functions=args.functions
    ))

if __name__ == "__main__":
    main()
